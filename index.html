<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Solarpunk Systems</title>
        <style>
            /* Heavily inspired by https://macwright.org/2019/02/09/tachyons-css.html */
            /* See also https://jrl.ninja/etc/1/ and https://news.ycombinator.com/item?id=19607169 */
            body {font-family: sans-serif; line-height: 1.3; padding: 1.25em; margin: auto}
            nav h1 {font-size: 1rem; margin: 0}
            nav ul {list-style:none; padding: 0; margin: 0.5em 0}
            code {padding: 0 2px}
            pre, code {font-family: Consolas, Menlo, monospace; background-color: Gainsboro} 
            pre {padding: 1em; font-size: 0.8rem}
            .bad {color: white; background-color: red}
            @media screen and (min-device-width: 480px) and (min-width: 1000px) {
                body {max-width: 600px; padding: 1.5em}
                nav {float: left; margin-left: -180px; margin-top: 0px; width: 180px}
                .selected:after {content: " <~"; color: red}
            }
        </style>
    </head>
    <body>
        <nav>
            <h1>Solarpunk Systems</h1>
            <ul id="pages"></ul>
        </nav> <!-- clear: left? -->

        <section id="sudoku-in-k" data-title="Sudoku in Shakti k">

        <h3>Sudoku in Shakti k</h3>

        <pre><code>p:(&|/p=)'+p,:,3/:3/p:!9 9
f:,/{@[x;y;]'10^x p y}'
s:{f/[,x;&~x]}
input:,/("200370009";"009200007"
         "001004002";"050000800"
         "008000900";"006000040"
         "900100500";"800007600"
         "400089001")-"0"
answer:s input
</code></pre>

        <p><a href="http://kparc.com/z/game.k">kparc.com's solver</a>, expressed in Shakti k and split over more than 2 lines.</p>
        <p>I did not invent this solver, but wanted to understand how it works.</p>
        <p>The short answer is: pick an unknown slot; for each number left after excluding the known numbers in the same row/column/box, create a candidate solution; repeat for each candidate solution until all slots are filled. You now have a list of solutions.</p>
        <hr>
        <p>Unknown cells are <code>0</code>s in the input. It's expressed as a string subtraction because it's shorter than writing the equivalent integer list literal.</p>
        <p><code>p</code> is a list of, for each cell in the Sudoku grid, the indices of all cells that directly restrict what its value can be (ie share a row, column and/or box). It is the same regardless of the input.</p>
        <ul>
            <li>It generates a list of box-row-col ID lists using floored int division (<code>3/</code>) and conversion from base 3 digits (<code>3/:</code>).
            <li>Then, for each ID list, it finds the indices of all cells that share with it a row, col or box (<code>(&|/p=)'</code>).</li>
        </ul>
        <p><code>s</code> returns a list of valid answers. <code>s</code> has shape <code>f/[x;y]</code> ie <code>x f/y</code>: it iterates left-to-right over the indices of the unknown cells (<code>&~x</code>), with an explicit starting state (<code>,x</code>). Each iteration fills one slot and returns an updated list of candidate solutions; that list, and the next unknown cell index, are inputs to the next iteration.</p>
        <p><code>f</code> does the real work in each iteration of <code>s</code>. It takes a list of candidate solutions and the index of an unknown cell, and returns the next set of WIP candidate solutions.</p>
        <ul>
            <li>The first iteration starts with the input puzzle (<code>,x</code>), enlisted because the iterator expects a <i>list</i> of candidate solutions.</li>
            <li><code>p</code> is used to get the known values of cells that contend with the unknown cell examined in that iteration (<code>x p y</code>), to determine which possible values remain (<code>10^</code>). A lot of the time, the contending cells will cover all legal values, being 0&ndash;9 (ie it's a dead end), so <code>10^</code> will return an empty list.
            <li><code>@[x;y;]'</code> just says "for each legal value this cell could take, generate a candidate solution for consideration in the next iteration that has the unknown cell filled with that value".</li>
        </ul>

        <p>When reading kparc's code, I couldn't understand how illegal solutions were weeded out. The answer is: if a candidate solution has no legal values for the unknown cell, then <code>10^</code> (and therefore <code>@[x;y;]'</code>) will return an empty list, so that solution won't spawn any children for inclusion in the candidate list used in the next iteration!</p>

        <hr>

        <p>We can see the candidate count (<code>#:</code>) change each iteration by switching from over (<code>/</code>) to scan (<code>\</code>):</p>

        <pre><code> / Candidate counts
 l: #:'{f\[,x;&~x]} input
 
 / 5-at-a-time for display
 ` 1:,/"\n"/:,/'-5$$Ã˜ 5#l
    3    5   13   12   10
   20   34   64  100   87
   46   81   71  142  112
   64   64  116  348 1010
 2670 3373 2706  664  455
  769 1857 3728 4480 3779
 1020  184  184  294  210
  120  100   49   98  196
  182   66   12   12   24
   38   14    1    1    1
    1    1    1    1    1</code></pre>

        <p>Unfortunately 'hard' puzzles require a different approach, such as the one mentioned in <a href="https://norvig.com/sudoku.html">Peter Norvig's article</a> about his own solver. Try:</p>

        <pre><code>input:,/("400000805";"030000000"
         "000700000";"020000060"
         "000080400";"000010000"
         "000603070";"500200000"
         "104000000")-"0"</code></pre>

         <p>But hey, come on: it's a Sudoku solver in two lines of code.</p>

         <hr>

         <p>If you'd like to learn more about Shakti k, there's an unofficial <a href="https://kcc.kparc.io/">tutorial</a> and <a href="https://kparc.github.io/ref/">reference</a>.</p>

         <p>See also John Scholes' <a href="https://www.youtube.com/watch?v=DmT80OseAGs">APL walk-through video</a> <!-- and <a href="">accompanying step-through</a> on TryAPL, -->and <a href="https://code.jsoftware.com/wiki/Essays/Sudoku">Roger Hui's solver in J</a>.</p>

<!--
        <p>TODO compare to Dyalog (Scholes video + tryapl) solver? Dyalog is generic on the problem size though.</p>

        <p>TODO compare to Peter Norvig's solution</p>

        TODO functions to convert TO and FROM a grid representation

        waht does it look like in j?

        </section>

        <h3>Speed tips</h3>
        
        <p>Try to avoid using 'each' (<code>'</code>) and 'window' (<code>':</code>).</p>

        <p><a href="https://en.wikipedia.org/wiki/Rule_30">Rule 30</a>:</p>
        <pre>
                #                             
               ###                            
              ##  #                           
             ## ####                          
            ##  #   #                         
           ## #### ###                        
          ##  #    #  #                       
         ## ####  ######                      
        ##  #   ###     #                     
       ## #### ##  #   ###                    
      ##  #    # #### ##  #                   
     ## ####  ## #    # ####                  
    ##  #   ###  ##  ## #   #                 
   ## #### ##  ### ###  ## ###                
  ##  #    # ###   #  ###  #  #               
 ## ####  ## #  # #####  #######              
##  #   ###  #### #    ###      #             
</pre>
        <code><pre>
/ setup
(r;c):16 60               / rows (iterations), columns
s:(2/c)=!c                / starting state

/ next state: left XOR (middle OR right)
n1:{{~x=y|z} .<span class="bad">'</span> 3<span class="bad">':</span>0,x,0} / original
n2:{{~x=y|z} . +3<span class="bad">':</span>0,x,0} / with help of k expert
n3:{~=[0,-1_x; x|1_x,0]}  / with more help of k expert

` 0: " #" r n1\ s;        / iterate, display  

/ check getting same results
~[r n1\ s; r n2\ s]       / 1
~[r n2\ s; r n3\ s]       / 1

/ performance
\t:1000 r n1\ s           / 1445
\t:1000 r n2\ s           / 550
\t:1000 r n3\ s           / 36
</pre></code>
-->
    <script>
    // Run on load AND on change of url hash (just a page 'go to'?)
    const ss = document.getElementsByTagName("section");
    const index = document.getElementById("pages");
    const current_article = new URL(document.URL).hash.slice(1);
    for (let i=0; i<ss.length; i++) {
        let e = ss[i];
        let id = e.id;
        let text = document.createTextNode(e.getAttribute("data-title"))
        let child = document.createElement("li")
        // make only for CURRENT article
        if (id == current_article) {
            child.classList.add("selected")
        }
        child.setAttribute("id", id)
        child.appendChild(text)
        index.appendChild(child)
        console.log()
    }
    /*
    
    */
    </script>
    </body>
</html>
